<!DOCTYPE html>
<html lang="en">
<head>
<script type="text/javascript">
  // This is a CodeSandbox injection script that's used to
  // add navigation and inspector functionality to the preview
  (function () {
    // 1) Get the <script> tag that's currently running:
    var me = document.currentScript;

    // 2) Create the blocking‚Äêstyle <script> to load:
    var script = document.createElement("script");
    script.src = "https://codesandbox.io/p/preview-protocol.js";

    // By default a dynamically‚Äêinserted <script> is async=true.
    // Turn async off to make it behave like a normal blocking <script>:
    script.async = false;
    // (Do NOT set defer.)

    // 3) Insert it immediately after the current <script>:
    me.parentNode.insertBefore(script, me);
  })();

  const isIFramePreview = window.top !== window.self;

  // Only run this script in editor context
  if (isIFramePreview) {
    // This script is used to enable Chrome DevTools functionality
    (function () {
      var script = document.createElement("script");
      script.src =
        "https://codesandbox.io/p/chrome-devtool/protocol/index.js";

      script.onload = () => {
        const devtoolProtocol = window.chobitsu;
        if (devtoolProtocol) {
          window.addEventListener("message", (event) => {
            const { type, data } = event.data;

            if (type === "FROM_DEVTOOL") {
              devtoolProtocol.sendRawMessage(data);
            }
          });

          devtoolProtocol.setOnMessage((data) => {
            if (data.includes('"id":"tmp')) {
              return;
            }

            window.parent.postMessage({ type: "TO_DEVTOOL", data }, "*");
          });

          devtoolProtocol.sendRawMessage(
            `{"id":5,"method":"Runtime.enable","params":{}}`
          );
        }        
      }

      (document.head || document.documentElement).prepend(script);
    })();
  }

  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
    let nextID = 0;
    let hook = (__REACT_DEVTOOLS_GLOBAL_HOOK__ = {
      renderers: new Map(),
      supportsFiber: true,
      inject: (renderer) => {
        const id = nextID++;
        hook.renderers.set(id, renderer);
        return id;
      },
      onScheduleFiberRoot() {},
      onCommitFiberRoot() {},
      onCommitFiberUnmount() {},
    });
  }

  document.currentScript.remove();
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Connection Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .status { padding: 10px; margin: 5px; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .test-results { margin-top: 20px; }
        #log { background: #000; color: #0f0; padding: 10px; height: 300px; overflow-y: scroll; font-family: monospace; }
    </style>
</head>
<body>
    <h1>üî¨ Real-time System Test</h1>
    
    <div id="connectionStatus" class="status info">Testing connection...</div>
    <div id="apiStatus" class="status info">Testing API endpoints...</div>
    <div id="websocketStatus" class="status info">Testing WebSocket...</div>
    <div id="pollingStatus" class="status info">Testing polling fallback...</div>
    
    <div class="test-results">
        <h3>Live Data Updates:</h3>
        <div id="voteCount">Vote Count: <span id="votes">Loading...</span></div>
        <div id="predictions">AI Confidence: <span id="confidence">Loading...</span></div>
        <div id="transactions">Latest Transaction: <span id="latestTx">Loading...</span></div>
    </div>
    
    <h3>System Log:</h3>
    <div id="log"></div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        const log = document.getElementById('log');
        const connectionStatus = document.getElementById('connectionStatus');
        const apiStatus = document.getElementById('apiStatus');
        const websocketStatus = document.getElementById('websocketStatus');
        const pollingStatus = document.getElementById('pollingStatus');
        
        function logMessage(message) {
            const timestamp = new Date().toLocaleTimeString();
            log.innerHTML += `[${timestamp}] ${message}\n`;
            log.scrollTop = log.scrollHeight;
        }
        
        function setStatus(element, message, type = 'info') {
            element.className = `status ${type}`;
            element.textContent = message;
        }
        
        // Test API endpoints
        async function testAPI() {
            try {
                logMessage('üîó Testing API endpoints...');
                
                const healthResponse = await fetch('http://localhost:5000/api/health');
                const health = await healthResponse.json();
                logMessage(`‚úÖ Health check: ${health.status}`);
                
                const predictionsResponse = await fetch('http://localhost:5000/api/ai/predictions/live');
                const predictions = await predictionsResponse.json();
                logMessage(`üîÆ AI Predictions: ${predictions.confidence}% confidence`);
                document.getElementById('confidence').textContent = `${predictions.confidence}%`;
                
                const transactionsResponse = await fetch('http://localhost:5000/api/live/transactions');
                const transactions = await transactionsResponse.json();
                logMessage(`‚õìÔ∏è Live transactions: ${transactions.count} available`);
                if (transactions.transactions && transactions.transactions.length > 0) {
                    const latest = transactions.transactions[transactions.transactions.length - 1];
                    document.getElementById('latestTx').textContent = latest.hash;
                }
                
                setStatus(apiStatus, '‚úÖ All API endpoints working', 'success');
                
            } catch (error) {
                logMessage(`‚ùå API Error: ${error.message}`);
                setStatus(apiStatus, `‚ùå API Error: ${error.message}`, 'error');
            }
        }
        
        // Test WebSocket connection
        function testWebSocket() {
            try {
                logMessage('üåê Testing WebSocket connection...');
                
                const socket = io('http://localhost:5000', {
                    transports: ['websocket', 'polling'],
                    timeout: 10000,
                    forceNew: true
                });
                
                socket.on('connect', () => {
                    logMessage('‚úÖ WebSocket connected successfully');
                    setStatus(websocketStatus, '‚úÖ WebSocket connected', 'success');
                    
                    // Request live data
                    socket.emit('request_live_data');
                    socket.emit('request_3d_data');
                    logMessage('üì° Requested live data from server');
                });
                
                socket.on('disconnect', () => {
                    logMessage('‚ö†Ô∏è WebSocket disconnected');
                    setStatus(websocketStatus, '‚ö†Ô∏è WebSocket disconnected', 'error');
                });
                
                socket.on('connect_error', (error) => {
                    logMessage(`‚ùå WebSocket connection error: ${error.message}`);
                    setStatus(websocketStatus, '‚ùå WebSocket connection failed', 'error');
                    startPollingFallback();
                });
                
                // Listen for real-time updates
                socket.on('enhanced_voting_update', (data) => {
                    logMessage('üìä Received voting update');
                    if (data.election_data && data.election_data.current_turnout) {
                        document.getElementById('votes').textContent = data.election_data.current_turnout.toLocaleString();
                    }
                });
                
                socket.on('prediction_update', (data) => {
                    logMessage(`üîÆ Received prediction update: ${data.confidence}%`);
                    document.getElementById('confidence').textContent = `${data.confidence}%`;
                });
                
                socket.on('blockchain_feed_update', (data) => {
                    logMessage('‚õìÔ∏è Received blockchain update');
                    if (data.transactions && data.transactions.length > 0) {
                        const latest = data.transactions[data.transactions.length - 1];
                        document.getElementById('latestTx').textContent = latest.hash || 'New transaction';
                    }
                });
                
                socket.on('new_transaction', (data) => {
                    logMessage('üí∞ New transaction received');
                    if (data.transaction) {
                        document.getElementById('latestTx').textContent = data.transaction.tx_hash || data.transaction.hash;
                    }
                });
                
                socket.on('vote_count_update', (data) => {
                    logMessage(`üó≥Ô∏è Vote count update: ${data.total_votes}`);
                    document.getElementById('votes').textContent = data.total_votes.toLocaleString();
                });
                
                setStatus(connectionStatus, 'üîÑ Connecting to WebSocket...', 'info');
                
            } catch (error) {
                logMessage(`‚ùå WebSocket setup error: ${error.message}`);
                setStatus(websocketStatus, `‚ùå WebSocket setup failed: ${error.message}`, 'error');
                startPollingFallback();
            }
        }
        
        // Polling fallback
        function startPollingFallback() {
            logMessage('üîÑ Starting polling fallback mechanism...');
            setStatus(pollingStatus, 'üîÑ Polling fallback active', 'info');
            
            setInterval(async () => {
                try {
                    // Poll for updates every 5 seconds
                    const [predictions, transactions] = await Promise.all([
                        fetch('http://localhost:5000/api/ai/predictions/live').then(r => r.json()),
                        fetch('http://localhost:5000/api/live/transactions').then(r => r.json())
                    ]);
                    
                    // Update UI with polled data
                    document.getElementById('confidence').textContent = `${predictions.confidence}%`;
                    
                    if (transactions.transactions && transactions.transactions.length > 0) {
                        const latest = transactions.transactions[transactions.transactions.length - 1];
                        document.getElementById('latestTx').textContent = latest.hash;
                    }
                    
                    logMessage('üîÑ Polling update successful');
                    setStatus(pollingStatus, '‚úÖ Polling fallback working', 'success');
                    
                } catch (error) {
                    logMessage(`‚ùå Polling error: ${error.message}`);
                    setStatus(pollingStatus, `‚ùå Polling error: ${error.message}`, 'error');
                }
            }, 5000);
        }
        
        // Run tests
        window.addEventListener('DOMContentLoaded', async () => {
            logMessage('üöÄ Starting real-time system tests...');
            
            // Test API first
            await testAPI();
            
            // Then test WebSocket
            setTimeout(() => {
                testWebSocket();
            }, 1000);
            
            // Set connection status
            setStatus(connectionStatus, '‚úÖ System tests initiated', 'success');
        });
    </script>
</body>
</html>